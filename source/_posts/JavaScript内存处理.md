---
title: JavaScript内存处理
date: 2022-08-05 22:59:00
updated: 2022-08-05 22:59:00
tags: JavaScript
categories: JavaScript
keywords:
description: JavaScript内存处理
top_img: https://sls-cloudfunction-ap-guangzhou-code-1300044145.file.myqcloud.com/upload/202208052258850.png
comments:
cover: https://sls-cloudfunction-ap-guangzhou-code-1300044145.file.myqcloud.com/upload/202208052258850.png
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---

# 垃圾回收

- JavaScript内存管理是自动的
- 对象不能从根上访问到（非可达）时是垃圾

**JavaScript可达对象**

- 能通过一切办法（引用，作用域链）访问到的对象，就称为可达对象
- 可达的标准就是从根触发是否能够被找到
- JavaScript中的根就是全局变量对象

# GC算法

GC就是垃圾回收机制的简写，可以帮我们自动找出内存中的垃圾，释放并回收空间。

## 引用计数算法

设置引用数，判断当前的引用数是否为0，如果为0则开始回收。

在代码执行的过程中，每个对象都有自己的引用计数，当有地方保存引用时，或者释放引用时，这个计数都会发生调整增加或者减少，一旦减少到0，则立即回收该对象，释放空间。

由于这一模式是实时运行（边运行，边回收），所以可以最大限度的防止程序内存满的情况。

也由于是实时运行，所以使程序运行时的时间开销比较大，并且要占用一定内存来访计数器。**并且该模式不能回收循环引用的情况(最重要)**。 

## 标记清除算法

分成**标记**和**清除**两个阶段：

1. 标记阶段：遍历所有对象，找出活动的对象（可达对象）并标记。
2. 清除阶段：遍历所有对象，没有标记的对象清除并回收，记录到空闲链表，有标记的对象清理标记。

该算法实现简单，但有两个缺点：1. **运行速度慢**，两个阶段都需要遍历整个堆。2.**空间碎片化**，清除后的空间是不连续的，不利于后续空间分配。且分配空间时需要遍历整个空闲链表

## 标记整理算法

标记清除算法的优化算法，**解决了空间碎片化**，其中也是分为**标记**和清除两个阶段：

1. 标记阶段：同**标记清除算法**一致。
2. 清除阶段：先对空间进行整理，把活动对象进行移动，将活动对象的地址变成一块连续的内存空间，再对剩余的内存空间进行整体回收。

这样一来，就不会大批量出现内存碎片空间，可以最大化利用释放出来的内存空间。

## 分代回收算法

内存分为新生代（存活时间较短的对象）、老生代，针对不同代，采用不同算法。

- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量

V8内存空间分成两大部分，小空间存储新生代对象，大空间存储老生代。 

### 新生代对象回收

新生代区域V8内存大小限制（64/32 32M/16M）

新生代对象区域回收算法只要用的是 **复制算法** 以及 **标记整理**。

新生代内存区分为两个等大小空间，一个称为From，一个称为To，活动对象存储于From空间。

一旦开始进行GC操作时，会对From进行**标记整理**后，再把活动对象拷贝至To，最后把From空间完全释放。

#### **对象晋升**

晋升，指的是从新生代对象变成老生代对象。From拷贝To过程中，可能出现对象晋升。

晋升的条件有两个：1.一轮GC有还存活的新生代对象 2. To空间的使用率超过了25%

### 老生代对象回收

老生代区域V8内存大小限制（64/32 1.4G/700M）

老生代对象区域回收算法只要用的是 **标记清除** 、**标记整理**、**增量标记算法**。

1. 首先使用标记清除算法完成垃圾空间回收
2. 当发生新生代晋升的时候，如果出现老生代空间不足的情况，则会采用标记整理算法，处理掉空间碎片。
3. 采用增量标记进行效率优化。

# 问题诊断

项目运行过程中，偶尔会出现一些内存相关的问题，导致整个应用使用变卡，甚至崩溃。

内存问题表现：

- 频繁垃圾回收：延迟加载或者经常性暂停
- 内存膨胀：持续性发生卡顿
- 内存泄露：随着时间，性能越来越差

 